# Схема БД v2 (модель подходов)

Целевое состояние после перехода на модель «один подход = одна запись». Рекорды считаются только из `daily_adds`; таблицы `user_records` и `records` не используются. Таблица `api_tokens` не используется: WebApp и API в v2 привязаны только к пользователю (user_id), не к чату — авторизация и привязка к чату через токен не нужны.

---

## Таблицы

### users
Профили пользователей Telegram.

| Колонка   | Тип         | Ограничения |
|-----------|-------------|-------------|
| user_id   | BIGINT      | PK          |
| username  | TEXT        |             |
| created_at| TIMESTAMPTZ | NOT NULL    |
| updated_at| TIMESTAMPTZ | NOT NULL    |

**Изменения относительно текущей схемы:** убраны `first_name` и `last_name`; добавлено `created_at`.

**Отображение имени пользователя:** в v2 везде (бот, WebApp, API) используем только `username`; если username пустой или недоступен — строка `"User " + user_id` (например, «User 123456»).

**Заполнение created_at при миграции:** для существующих пользователей взять дату первой записи этого пользователя в `daily_counts` — например `MIN(updated_at)` по строкам с данным `user_id`. Новые пользователи: `created_at = NOW()` при первом INSERT.

---

### daily_adds *(новая)*
Один подход = одна запись. Все добавления (add) пишутся сюда; рекорды и итоги за день считаются агрегациями по этой таблице. Подходы привязаны только к пользователю и дате; привязка к чату (кто в каком чате виден) — через `shared_chats` (см. «Участники чата» ниже).

| Колонка   | Тип         | Ограничения        | Описание |
|-----------|-------------|--------------------|----------|
| id        | BIGSERIAL   | PK                 | Идентификатор подхода |
| user_id   | BIGINT      | NOT NULL, FK→users | Кто добавил |
| date      | DATE        | NOT NULL           | Дата подхода (будущие даты запрещены) |
| count     | INTEGER     | NOT NULL           | Количество отжиманий в этом подходе; строго от 1 до 1000 |
| created_at| TIMESTAMPTZ | NOT NULL           | Время добавления (аналитика) |
| migrated  | BOOLEAN     | NOT NULL DEFAULT FALSE | TRUE = портировано из daily_counts, в рекорды не входит |

**Ограничения (CHECK):**
- `count > 0 AND count <= 1000`
- `date <= CURRENT_DATE` (будущие даты запрещены)

**Индексы (рекомендуемые):**
- `(user_id, date)` — итог за день, история, рекорды по пользователю; статус по чату — сначала список «участников чата» из shared_chats, затем запрос по user_id IN (...)
- `(user_id, date)` WHERE migrated = FALSE — рекорды пользователя
- `(created_at)` — аналитика по времени

---

### shared_chats
Связка «результаты пользователя доступны в этом чате». Одна запись = пользователь «подключён» к чату: его подходы из `daily_adds` видны остальным участникам этого чата (статус за день, лидерборд и т.д.).

**Когда добавляется запись:**
- пользователь сделал **add** в этом чате (достаточно одного добавления), или
- пользователь выполнил команду **share** в этом чате.

В обоих случаях в `shared_chats` добавляется пара `(chat_id, user_id)`. Команда **hide** удаляет эту запись — результаты пользователя в данном чате больше не показываются.

| Колонка    | Тип         | Ограничения        |
|------------|-------------|--------------------|
| chat_id    | BIGINT      | NOT NULL, PK (часть) |
| user_id    | BIGINT      | NOT NULL, PK (часть), FK→users |
| created_at | TIMESTAMPTZ | NOT NULL           |

**Участники чата (кто виден в этом чате):** это просто список пользователей, чьи результаты показываются в данном чате. Он совпадает со списком записей в `shared_chats` для этого чата: **`SELECT user_id FROM shared_chats WHERE chat_id = ?`**. Отдельной таблицы «участники чата» нет — только shared_chats. При запросе «статус за дату» или «лучший подход в чате сегодня» берём эти user_id и дальше агрегируем данные из `daily_adds` по ним.

**Индексы:**
- `(user_id)` — список чатов, в которых видны результаты пользователя
- `(chat_id)` — запрос «кто виден в этом чате» (участники чата)

---

### migration_flags
Флаги применённых миграций и бэкфиллов.

| Колонка    | Тип         | Ограничения |
|------------|-------------|-------------|
| name       | TEXT        | PK          |
| applied_at | TIMESTAMPTZ | NOT NULL    |

---

## Таблицы только для миграции / архив (не для новой логики)

### daily_counts *(deprecated после перехода)*
Старая модель: одна строка на (chat_id, user_id, date), обновляемая на месте. После портирования данных в `daily_adds` запись сюда не ведётся; таблицу можно оставить как архив или удалить позже.

| Колонка   | Тип         |
|-----------|-------------|
| chat_id   | BIGINT      |
| user_id   | BIGINT      |
| date      | DATE        |
| count     | INTEGER     |
| updated_at| TIMESTAMPTZ |
| PK (chat_id, user_id, date) |

---

### user_records *(убрать)*
Рекорды пользователя (max_add, лучший день). В v2 не используется — все рекорды считаются из `daily_adds` (WHERE migrated = FALSE). Таблицу можно удалить после перехода.

---

### records *(убрать)*
Устаревшая таблица рекордов по чату. В v2 не используется. Удалить после перехода.

---

### api_tokens *(убрать)*
Токен доступа к API, привязанный к чату. В v2 не используется: WebApp и API привязаны только к пользователю (user_id), не к чату. Авторизацию и привязку к пользователю решаем без этой таблицы. Удалить после перехода.

---

## Связи (целевая модель)

```
users ◄─────────────────── shared_chats
  ▲                              (chat_id — просто число, отдельной таблицы чатов нет)
  │
  └── daily_adds (user_id)
        • один пользователь — много подходов; chat_id в таблице нет
        • видимость в чате: shared_chats + список участников чата

WebApp/API в v2 привязаны только к user_id; api_tokens не используется.
```

---

## Порядок миграций (важно)

При создании схемы с нуля и при пошаговой миграции нужно соблюдать порядок из‑за внешних ключей и зависимостей данных.

1. **users** — базовая таблица; все остальные ссылаются на user_id. Сначала создать/изменить users (добавить created_at, убрать first_name/last_name; заполнить created_at из MIN(updated_at) по daily_counts по user_id).
2. **daily_adds** — создаётся после users (FK user_id → users). Индексы создаются сразу после таблицы.
3. **shared_chats** — уже существует, ссылается на users. При миграции достаточно добавить индекс по (chat_id), если его ещё нет.
4. **migration_flags** — можно создать в любой момент (не зависит от users/daily_adds).
5. **Портирование данных:** после создания daily_adds выполнить миграцию из daily_counts: группировка по (user_id, date), для каждой группы одна или несколько записей в daily_adds с migrated = TRUE, date = дата группы, created_at = MIN(updated_at) по группе (или началу дня). Сумму по группе разбить на подходы по правилу: каждая запись должна иметь count от 1 до 1000 (CHECK). Например, если SUM(count) > 1000, вставить несколько записей по 1000 и остаток (или одну 1000 и обрезать — явно выбрать стратегию). Будущие даты в daily_counts не портировать; count <= 0 в исходных строках пропускать или не включать в сумму.
6. **Удаление/отключение:** после перехода на чтение из daily_adds перестать писать в daily_counts; позже при необходимости удалить user_records, records, api_tokens, daily_counts.

---

## Пример SQL: создание daily_adds и индексов shared_chats

```sql
-- daily_adds (создавать после users)
CREATE TABLE daily_adds (
  id         BIGSERIAL PRIMARY KEY,
  user_id    BIGINT NOT NULL REFERENCES users (user_id),
  date       DATE NOT NULL,
  count      INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  migrated   BOOLEAN NOT NULL DEFAULT FALSE,
  CONSTRAINT daily_adds_count_range CHECK (count > 0 AND count <= 1000),
  CONSTRAINT daily_adds_date_not_future CHECK (date <= CURRENT_DATE)
);

CREATE INDEX daily_adds_user_date_idx
  ON daily_adds (user_id, date);

CREATE INDEX daily_adds_user_date_migrated_idx
  ON daily_adds (user_id, date) WHERE migrated = FALSE;

CREATE INDEX daily_adds_created_at_idx
  ON daily_adds (created_at);

-- Индекс shared_chats по chat_id (если ещё нет)
CREATE INDEX IF NOT EXISTS shared_chats_chat_id_idx
  ON shared_chats (chat_id);
```

---

## Производные данные (без отдельных таблиц)

| Что нужно           | Как получить из daily_adds |
|---------------------|-----------------------------|
| Итог за день (user) | SUM(count) WHERE user_id, date |
| Лучший подход (user)| MAX(count) WHERE user_id AND migrated = FALSE |
| Лучший день (user)  | SUM(count) GROUP BY date → MAX, дата |
| Лучший подход в чате сегодня | Участники чата = SELECT user_id FROM shared_chats WHERE chat_id = ?; затем MAX(count) по daily_adds за сегодня по этим user_id |
| Статус за дату (чат)| Участники чата = SELECT user_id FROM shared_chats WHERE chat_id = ?; затем SUM(count) по user_id, date из daily_adds |
| История (user)      | SUM(count) GROUP BY date для user_id |

---

## Анализ: решения и открытые вопросы

### Принятые решения

- **Участники чата** — это список user_id из `shared_chats` для данного chat_id: `SELECT user_id FROM shared_chats WHERE chat_id = ?`. Отдельной сущности нет; этим списком пользуемся для «статус за дату (чат)», «лучший подход в чате сегодня» и т.д.
- **Ограничения daily_adds:** `count` строго от 1 до 1000 (CHECK); будущие даты запрещены (`date <= CURRENT_DATE`).
- **Отображение имени:** username; если недоступен — «User {user_id}».
- **Индекс shared_chats:** добавлен индекс по `(chat_id)`.
- **Портирование из daily_counts:** группировка по (user_id, date); для каждой группы одна или несколько записей в daily_adds (каждая с count 1–1000, при SUM > 1000 — несколько строк по 1000 и остаток), migrated = TRUE. Подробно — раздел «Порядок миграций» выше.
- **Порядок миграций:** зафиксирован в разделе «Порядок миграций» выше.

### Авторизация WebApp/API без api_tokens (идеи)

Привязка только к user_id; способ проверки личности не задан. Варианты:

1. **Telegram Web App initData.** При открытии WebApp из бота Telegram передаёт в URL или в `window.Telegram.WebApp.initData` подписанные данные (в т.ч. user). Бэкенд проверяет подпись (HMAC с секретом от BotFather), извлекает user_id и выдаёт сессию или JWT с этим user_id. Плюсы: без пароля, пользователь уже авторизован в Telegram. Минусы: только для клиентов внутри Telegram.

2. **JWT с user_id.** После первой проверки (например, через initData или одноразовый код из бота) сервер выдаёт JWT с payload { user_id, exp }. Клиент передаёт заголовок Authorization: Bearer <jwt>. Сервер проверяет подпись и читает user_id. Плюсы: stateless, удобно для API. Минусы: нужен безопасный канал первой выдачи (initData или бот).

3. **Сессия по cookie.** После проверки initData или кода из бота сервер создаёт сессию (хранилище Redis/БД), ставит cookie, в сессии хранит user_id. Дальше запросы с cookie — сервер достаёт user_id из сессии. Плюсы: привычная модель. Минусы: нужен Redis или таблица сессий; кросс-домен и мобильный WebApp — нюансы с cookie.

4. **Комбо: initData для входа → JWT для API.** При первом открытии WebApp клиент шлёт initData на POST /auth; сервер проверяет подпись Telegram, извлекает user_id, создаёт пользователя в users при необходимости, возвращает JWT с user_id. Дальше все запросы с Authorization: Bearer <jwt>. Реализация простая, один механизм для WebApp и для прямых вызовов API с тем же JWT.

**Рекомендация:** вариант 4 (initData → JWT): одна точка входа, понятная модель, подходит для WebApp из бота и для мобильного клиента с тем же JWT.

### Отложено

- **Производительность агрегатов** — пока полагаемся на индексы; материализованные представления/кэш при необходимости позже.
- **Удаление пользователя (GDPR)** — политику зафиксировать при появлении требований.
