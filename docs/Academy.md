# Academy — архитектура приложения G8 Adjumannya

Документ описывает полную архитектуру приложения, слабые места и варианты перехода к более стабильной архитектуре без потери данных.

---

## 1. Обзор приложения

**G8 Adjumannya** — бот и веб‑приложение для группового челленджа «100 отжиманий в день». Участники добавляют результаты в Telegram‑чате или через WebApp; данные хранятся в PostgreSQL и отображаются в виде статуса за день, рекордов и календаря.

**Точки входа:**
- **Telegram‑бот** — команды `/add`, `/status`, `/record`, `/correct`, `/share`, `/hide`, `/web`, `/force`, `/help`.
- **HTTP API** — REST для WebApp: `POST /add`, `GET /status`, `GET /records`, `GET /history`.
- **WebApp (Vue 3 + Pinia)** — SPA с токеном из бота, отдаётся тем же сервером (Express) из `web/dist`.

**Запуск:** один процесс `server.js` поднимает и `initDb()`, и Express (API + статика), и бота (`startBot({ skipInitDb: true })`). Отдельно можно запускать только бота (`start:bot`) или только API (`start:api`).

---

## 2. Слой данных (PostgreSQL)

### 2.1 Таблицы

| Таблица | Назначение | Ключ |
|--------|------------|------|
| **users** | Профили Telegram: user_id, username, first_name, last_name, updated_at | user_id (PK) |
| **daily_counts** | Отжимания по дням: chat_id, user_id, date, count, updated_at | (chat_id, user_id, date) PK |
| **shared_chats** | Связка «пользователь показывается в чате»: chat_id, user_id, created_at | (chat_id, user_id) PK |
| **user_records** | Глобальные рекорды пользователя: max_add (лучший разовый add), record_count (лучший день), record_date | user_id (PK) |
| **records** | Устаревшая таблица «рекорды по чату»; в коде не используется для чтения, только в initDb для миграции в user_records | (chat_id, user_id) PK |
| **api_tokens** | Токен для API, привязан к chat_id (один токен на чат) | token (PK), unique(chat_id) |
| **migration_flags** | Флаги выполненных миграций/бэкфиллов | name (PK) |

### 2.2 Ключевые инварианты

- **Запись daily_counts:** всегда идёт в один «канонический» чат на пользователя. Если пользователь в `shared_chats` — пишем в чат с минимальным `chat_id` среди его shared‑чатов (`resolveWriteChatId`). Иначе — в текущий чат. Так достигается: одна логическая запись за (user, date) при share между чатами, но физически строка одна на (chat_id, user_id, date).
- **Чтение при share:** для пользователей из `shared_chats` в данном чате данные берутся как **сумма** по всем `daily_counts` этого user_id за дату (агрегация по чатам). Локальные пользователи (без share в этом чате) читаются только по `chat_id` этого чата. В итоге в одном чате видны и «свои» участники, и «пришедшие» по share.
- **user_records:** обновляются при каждом `/add` (лучший разовый add и лучший день по record_count/record_date) и при `/correct` через полный пересчёт лучшего дня по `daily_counts` (`syncUserRecord` → `getBestRecordForUser`).

### 2.3 Основные функции db.js

- **initDb()** — блокировка `pg_advisory_lock`, создание таблиц, индексы, миграции колонок для `records`, синхронизация `user_records` из `records`, опциональный бэкфилл (выключен). Разблокировка в `finally`.
- **addCount({ chatId, userId, date, delta })** — INSERT/UPDATE в `daily_counts` в канонический чат, RETURNING count (одна строка).
- **getTotalCountForUserDate(userId, date)** — SUM(count) по всем чатам для пользователя и даты (для корректного «Всего» в ответе add и в API).
- **setCountForUserDate(chatId, userId, date, count)** — DELETE всех строк (user_id, date), затем INSERT одной строки в канонический чат (используется в `/correct` для режима «установить»).
- **getBestRecordForUser(userId)** — лучший день по SUM(count) по датам.
- **syncUserRecord(userId)** — перезаписывает в user_records record_count и record_date из getBestRecordForUser (max_add не трогает при correct).
- **updateRecord({ chatId, userId, count, date })** — upsert в user_records, обновляет max_add и record_count/record_date только если новые значения лучше.
- **getStatusByDate(chatId, date)** — список участников за дату: для shared‑пользователей — сумма по всем чатам, для остальных — только по данному chat_id; объединение и сортировка по count.
- **getUserHistory(chatId, userId)** — история по дням: при share — SUM по всем чатам по датам, иначе только по chat_id.
- **hasUserReached100(chatId, userId)** — есть ли у пользователя хотя бы один день с count >= 100 (с учётом share).
- **getRecordsByChat(chatId)** — «eligible» пользователи (те, у кого есть daily_counts в этом чате или запись в shared_chats для этого чата), их user_records, сортировка по record_count.
- **resolveWriteChatId(chatId, userId)** — канонический чат для записи (см. выше).
- **api_tokens** — createApiToken, getApiTokenByChat, getChatIdByToken; токен в заголовке Authorization привязывает запрос к chat_id.

Дублирование: таблица `records` создаётся и заполняется в initDb из старых данных, но чтение рекордов везде идёт из `user_records`.

---

## 3. Telegram‑бот (Telegraf)

### 3.1 Точка входа и зависимости

- **index.js** — создаёт бота, session, подключает db, парсеры (`createParsers(dayjs, ERRORS)`), хендлеры (add, status, record, force, share, hide, correct, apiToken). Использует `createDeletionHelpers(bot, 30_000)` для автоудаления сообщений.
- **server.js** — вызывает `initDb()`, создаёт Express‑приложение (`createApiApp()`), слушает порт, затем `startBot({ skipInitDb: true })`.

### 3.2 Удаление сообщений (deletionQueue.js)

- Очередь с таймером: для каждого сообщения задаётся `deleteAt = now + delayMs` (или override). По таймеру вызывается `bot.telegram.deleteMessage(chatId, messageId)`.
- **sendEphemeral(ctx, text, extra, overrideDelayMs)** — отправляет ответ и ставит его в очередь на удаление.
- Для команд в middleware по первому слову текста вызывается **scheduleDeleteMessage(ctx, delay)** для самого сообщения пользователя (status/record — 10 с, остальные кроме add — 30 с).

### 3.3 Команды и потоки

- **add** — парсится `parseAdd` (несколько чисел → sum, max, values). Если аргументов нет — «Сколько отжиманий добавить?» + force_reply, в session ставится waitingForAdd с таймаутом 15 с. Ответ на это сообщение или на текст без `/` обрабатывается в `bot.on('text')`: parseAddNumbers → handleAdd. В add: sum идёт в addCount, max в updateRecord, ответ «Всего» через getTotalCountForUserDate; при первом достижении 100 — отдельное сообщение FIRST_100_MESSAGE.
- **correct** — parseCorrect: `50` (set), `+5` (add), `-5` (subtract). setCountForUserDate / addCount с ±delta, затем syncUserRecord. Ответ: «Исправлено. Установлено/Добавлено/Отнято N / Сегодня: total».
- **status** — parseStatusDate (дата или сегодня), getStatusByDate, форматирование с progress bar и эмодзи.
- **record** — getRecordsByChat, вывод рекордов (max_add, record_date).
- **share / hide** — addSharedChat / removeSharedChat для текущего чата и user_id.
- **web** — получение/создание api_tokens по chat_id, формирование URL WebApp (token, user_id, api_base). В группе — попытка отправить кнопку в личку; иначе кнопка в ответ в чат.
- **force** — parseForce (@username), случайное сообщение из FORCE_MESSAGES, ответ с упоминанием.
- **help** — текст HELP_TEXT.
- **cancel** — сброс waitingForAdd в session.

Текст без `/` дополнительно проверяется на parseRecord, parseAdd, parseStatusDate — чтобы можно было писать «record», «add 5», «status 01.02.2026» без слэша (с учётом stripLeadingMention).

### 3.4 Парсеры (parse.js)

- **parseAddNumbers(str)** — разбивка по пробелам, только неотрицательные целые; возвращает `{ sum, max, values }` или null.
- **parseAdd(text)** — команда add + аргументы, делегирует parseAddNumbers.
- **parseCorrect(text)** — `correct N` / `correct +N` / `correct -N` → `{ mode, value }`.
- **parseStatusDate(text)** — дата DD.MM.YYYY или сегодня.
- **parseRecord(text)** — совпадение с «record» без аргументов.

Форматирование (format.js): displayName, progress bar, эмодзи мест, случайная фраза для add.

---

## 4. HTTP API (Express)

- **api/server.js** — createApiApp: json(), раздача статики из `web/dist`, health, затем маршруты с **authMiddleware** (Bearer token → getChatIdByToken → req.chatId).
- **POST /add** — user_id, delta, опционально date и user. upsertUser при наличии user, addCount, getTotalCountForUserDate, ответ `{ total }`, плюс уведомление в чат через Telegram (formatAddHeader + «+delta / Всего: total») если есть BOT_TOKEN.
- **GET /status** — query date, getStatusByDate(req.chatId, date), ответ `{ date, rows }`.
- **GET /records** — getRecordsByChat(req.chatId), ответ `{ rows }`.
- **GET /history** — query user_id, getUserHistory(req.chatId, userId), ответ `{ user_id, chat_id, days }` (days — объект date → count).
- **GET *** — index.html (SPA fallback).

API не вызывает updateRecord при /add: рекорд обновляется только в боте при handleAdd. То есть добавление через WebApp обновляет только daily_counts и total; user_records для max_add/record_count обновляются только при следующем add в боте или при correct. Это расхождение между ботом и API.

---

## 5. WebApp (Vue 3)

- **Сборка:** Vite, выход в `web/dist`, раздаётся Express.
- **Авторизация:** token, user_id, api_base из query при открытии из бота; сохраняются в Pinia (auth store) и в localStorage. Без token/api_base показывается «Нет доступа».
- **Данные:** Pinia store data — statusRows, recordsRows, historyDays. loadAll = loadStatus + loadRecords + loadHistory(userId). addCount в WebApp: POST /add, затем loadStatus, loadRecords, loadHistory.
- **Экраны:** заголовок, «Сегодня» (статус + ввод добавления), «Лучшие результаты», «Статистика» (дни участия, всего, среднее), календарь по месяцам с переключением. Режим VITE_DEMO=1 — моковые данные без API.
- **История:** привязана к user_id (из настроек/query); history загружается по этому user_id. Календарь и статистика считаются из historyDays.

---

## 6. Конфигурация и окружение

- **.env:** BOT_TOKEN, DATABASE_URL, PORT/API_PORT, WEB_APP_URL (для кнопки WebApp). PGSSLMODE=disable при необходимости.
- Один инстанс: бот + API + статика в одном процессе (server.js) или раздельно start:bot / start:api.

---

## 7. Критические проблемы модели данных

Сейчас результат за день хранится **одной записью** в `daily_counts` (одна строка на chat_id, user_id, date), которую мы **обновляем** при каждом добавлении (count += delta). Отдельные «подходы» (каждый вызов add с конкретным числом) в БД не сохраняются.

Из этого следуют три принципиальных ограничения:

**1) Невозможно отредактировать или удалить конкретный подход.**  
Пользователь не может сказать: «я по ошибке добавил 10, убери этот подход» или «измени третий подход с 20 на 15». Есть только одно число за день — его можно менять только целиком через `/correct` (установить в N, прибавить или отнять). Удалить/изменить один из нескольких подходов за день нельзя.

**2) Рекорды вынуждены хранить в отдельной таблице.**  
Лучший разовый подход (max_add) и лучший день по сумме (record_count) нельзя вывести из «таблицы подходов», потому что её нет. Поэтому мы поддерживаем `user_records` и при каждом add/correct вручную обновляем max_add и record_count/record_date. Рекорды — производные данные, но из-за модели мы не можем считать их запросом к сырым данным (MAX по подходам, SUM по дням), только дублировать логику в коде и в отдельной таблице.

**3) Недоступна аналитика по времени активности.**  
Мы не пишем время каждого добавления — только дату и итог за день (и updated_at у одной строки, который перезаписывается). Поэтому нельзя анализировать, в какое время дня человек чаще добавляет подходы, когда пики активности по чатам, по часам и т.д.

Итого: текущая модель «одно число за день, обновляемое на месте» — корневая причина отсутствия редактирования/удаления подходов, необходимости отдельной таблицы рекордов и отсутствия временной аналитики. Остальные слабые места (раздел 8) — следствия или отдельные недочёты; перечисленные три — прямые следствия выбора модели хранения.

---

## 8. Слабые места архитектуры

1. **Две модели рекордов (records и user_records)**  
   Таблица `records` (per‑chat) создаётся и в initDb синхронизируется в user_records, но в приложении читаются только user_records. Дублирование схемы и миграционная логика усложняют поддержку и риск рассинхронизации.

2. **Нет явных миграций**  
   Состояние схемы задаётся в initDb (CREATE IF NOT EXISTS + DO $$ с проверками information_schema). Нет нумерованных миграций (например, Flyway/Liquibase), откат и воспроизводимость окружений сложнее.

3. **Рекорд при добавлении через API не обновляется**  
   POST /add не вызывает updateRecord/syncUserRecord. Рекорды (max_add, record_count) обновляются только при add/correct в боте. Пользователь, добавляющий только через WebApp, не попадёт в рекорды по max_add/record_count до первого add в боте.

4. **Токен API привязан к чату, а не к пользователю**  
   Один токен на chat_id. Все участники чата, открывшие WebApp с одной кнопки, работают с одним и тем же chat_id (корректно для статуса/рекордов чата), но смена токена или доступ к «чужому» чату возможны только через нового бота/чат. Нет разделения «пользователь — чат» на уровне токена (например, user_id в токене).

5. **Share и запись в один чат**  
   При нескольких чатах у пользователя все записи daily_counts пишутся в канонический чат (MIN(chat_id)). Исторически могли остаться строки в других чатах (до введения share). getTotalCountForUserDate суммирует по всем чатам — логика корректна, но смешение «одна запись на дату» и «несколько строк на дату из прошлого» создаёт хрупкость при любом изменении правил записи.

6. **correct с отрицательным итогом**  
   setCountForUserDate при count < 0 только удаляет строки; addCount с отрицательным delta может дать отрицательный count в daily_counts. Отрицательные значения нигде явно не запрещены и могут сбивать статистику и рекорды.

7. **Сессия бота в памяти**  
   Telegraf session() по умолчанию — in‑memory. При рестарте процесса waitingForAdd и прочие флаги теряются. Для одного инстанса допустимо, при масштабировании бота на несколько воркеров сессия не разделяется.

8. **Нет идемпотентности и блокировок при записи**  
   addCount и setCountForUserDate не используют явных блокировок строк или уникальных ключей запроса. При двух одновременных add/correct за один день возможны гонки (два addCount с разными delta — оба применятся, но порядок не гарантирован). Для малой группы приемлемо, для большей нагрузки — риск.

9. **Удаление сообщений без гарантий**  
   Очередь удалений в памяти; при падении процесса сообщения останутся. Нет персистентной очереди и повторных попыток. Ошибки deleteMessage только логируются (.catch(() => {})).

10. **Единая точка отказа**  
    Один процесс: падение бота или API роняет и то и другое. Раздельный запуск (start:bot / start:api) возможен, но тогда initDb вызывается дважды при старте двух процессов — advisory lock снимается после первого initDb, второй спокойно проходит. Два процесса, пишущих в одну БД, увеличивают нагрузку на initDb и миграции.

11. **Нет rate limit и валидации объёмов**  
    API и бот не ограничивают частоту запросов и размер delta/значений. Теоретически возможны огромные числа или спам запросов.

12. **Веб: один user_id для истории**  
    История и календарь в WebApp привязаны к одному user_id (из настроек/query). Смена пользователя в интерфейсе без смены токена даёт доступ к истории другого пользователя в том же чате (данные чата общие) — это осознанное поведение, но с точки зрения «личные данные» может требовать явного разделения (например, проверка user_id по токену).

---

## 9. Варианты перехода к более стабильной архитектуре

Цель: устранить слабые места, сохранив существующие данные и по возможности минимизировать простои.

### 9.1 Сохраняем данные (общие принципы)

- Все изменения схемы — только добавление колонок/таблиц и миграции с копированием; без DROP данных до появления замены и проверки.
- Перед отключением `records` — убедиться, что все нужные рекорды уже в user_records (уже делается в initDb).
- Бэкфиллы и пересчёты — по флагам в migration_flags или по версии миграции, с возможностью отката только вперёд (новые поля nullable или с default).

### 9.2 Переход на модель «подходов» (решение критических проблем §7)

Чтобы получить возможность редактировать/удалять конкретный подход, считать рекорды из сырых данных и вести аналитику по времени, нужна модель **«один подход = одна запись»**.

**Новая сущность (таблица `daily_adds`):**
- Актуальная схема и ограничения — **db-schema-v2** (раздел «daily_adds»). В daily_adds нет колонки `chat_id`: подходы привязаны только к `user_id` и `date`; видимость в чате (кто в каком чате виден) — через таблицу `shared_chats`. Поля: `id` (PK), `user_id`, `date` (DATE), `count` (1–1000), `created_at` (TIMESTAMPTZ), **`migrated` (BOOLEAN, по умолчанию FALSE)**.
- Один вызов add 5 10 15 → три строки в daily_adds с count 5, 10, 15; у новых записей `migrated = FALSE`.

**Производные данные:**
- Итог за день: `SUM(count) WHERE user_id = ? AND date = ?` (с учётом share — суммирование по всем чатам пользователя за дату). Учитываются **все** строки (и портированные, и новые) — календарь и история за день полные.

**Все рекорды — только из таблицы daily_adds.**  
Отдельная таблица рекордов (user_records и т.п.) больше не нужна: любой рекорд считается запросом к daily_adds с условием `migrated = FALSE` (портированные данные в рекорды не входят). Примеры:
- **Твой лучший подход** — `MAX(count)` по подходам пользователя (user_id, migrated = FALSE).
- **Твой лучший день** — дата с максимальной суммой за день: `SUM(count) GROUP BY user_id, date`, затем MAX по сумме.
- **Лучший подход в чате сегодня** — `MAX(count)` по подходам за сегодня в данном chat_id (с учётом eligible users: кто добавлял в этом чате или shared в него).
- **Лучший день в чате** — по каждому пользователю лучший день (сумма за дату), затем сравнение между пользователями чата.
- И так далее — любые «топы» и рекорды выводятся из daily_adds агрегациями и фильтрами (по чату, дате, user_id, migrated).

**Редактирование и удаление:**
- Удалить подход = `DELETE FROM daily_adds WHERE id = ?` (с проверкой прав: свой user_id или модератор).
- Редактировать подход = `UPDATE daily_adds SET count = ? WHERE id = ?`. После изменений пересчёт рекордов — по запросу к таблице подходов или обновление кэша.

**Расширение API под редактирование и удаление подходов (вторая критическая задача):**
- Текущий API не умеет работать с отдельными подходами — только добавлять (POST /add) и читать статус/историю/рекорды агрегатами. Чтобы пользователь мог редактировать и удалять конкретный подход из WebApp или бота, API нужно расширить:
  - **Список подходов за день (и опционально за период):** например `GET /approaches` с query `user_id`, `date` (и при необходимости `date_to`). Ответ — массив записей с `id`, `date`, `count`, `created_at`, `migrated`, чтобы клиент мог показать список подходов и кнопки «изменить» / «удалить».
  - **Редактирование подхода:** `PATCH /approaches/:id` (или `PUT /approaches/:id`) с телом `{ "count": N }`. Проверка прав: подход принадлежит user_id, привязанному к чату токена (или текущий user_id в сессии). После обновления при необходимости пересчитать/вернуть обновлённый итог за день и рекорды.
  - **Удаление подхода:** `DELETE /approaches/:id`. Проверка прав — те же. Ответ — подтверждение и при необходимости обновлённый итог за день.
- В боте: команды вида `/delete_approach <id>` или выбор из списка за сегодня (inline-кнопки), `/edit_approach <id> <новое_число>` или интерактивный выбор. Оба сценария опираются на те же эндпоинты API или на прямые вызовы db из бота.
- Итог: без расширения API редактирование и удаление подходов возможны только внутри бота при прямом доступе к БД; WebApp и единая логика прав/валидации требуют явных эндпоинтов для списка подходов, PATCH и DELETE по id.

**Упрощение после перехода: убрать команду correct.**  
Когда модель подходов и эндпоинты редактирования/удаления подходов будут внедрены, команду **`/correct`** и все связанные с ней методы можно **удалить**. Корректировка результата за день будет сводиться к редактированию или удалению конкретных подходов (PATCH/DELETE по id) вместо «установить день в N» / «прибавить/отнять N». Что убрать: команда `correct` в боте, хендлер `handleCorrect` и `createCorrectHandler`, парсер `parseCorrect`; в db — `setCountForUserDate` (запись в daily_counts «одним числом» больше не нужна при записи только в таблицу подходов). Таблица `user_records` и функции `syncUserRecord` / `getBestRecordForUser` больше не нужны: рекорды берутся только из daily_adds (см. выше). Логика «correct: set/add/subtract к одному числу за день» полностью заменяется операциями над отдельными подходами.

**Аналитика по времени:**
- По `created_at` можно строить распределение по часам/дням недели, пики активности, сравнение пользователей.

**Миграция существующих данных (без потери). Принятый компромисс:**
- Старые данные из `daily_counts` **портируются** в новую таблицу подходов: **группировка по (user_id, date)**; для каждой группы вставляется **одна или несколько** записей в daily_adds так, чтобы каждая запись имела count от 1 до 1000 (CHECK в схеме). При SUM(count) по группе > 1000 — несколько строк (например по 1000 и остаток). У всех записей: date = дата группы, created_at = MIN(updated_at) по группе (или началом дня), **migrated = TRUE**. Будущие даты не портируем; count <= 0 в исходных строках пропускаем или не включаем в сумму. Подробно — **db-schema-v2**, раздел «Порядок миграций».
- **Портированные данные не учитываются в рекордах.** Все рекорды (лучший подход, лучший день, лучший в чате сегодня и т.д.) считаются только по строкам с `migrated = FALSE`. Итог за день, календарь и история считаются по всем строкам (и с migrated = TRUE, и с FALSE) — старые дни остаются видимыми и входят в сумму за день.
- Итог: история и календарь полные, без потери данных; рекорды «обнуляются» в смысле старых дней и считаются только по подходам после перехода на новую модель. Портированные записи можно редактировать/удалять как обычные (для корректировки старых итогов), но в рекорды они по-прежнему не входят.
- После переноса чтения на daily_adds и отключения записи в daily_counts таблицу daily_counts можно оставить для архива или постепенно вывести из употребления.

**Переход бота на запись в daily_adds:** реализация API v2 предполагает, что **бот в том же релизе** переводится на запись в daily_adds (и перестаёт писать в daily_counts). Иначе API v2 будет писать в daily_adds, а бот — в daily_counts, и данные разойдутся. Точки в боте, которые должны вызывать функции работы с daily_adds: **add** (добавление подходов), **correct** (до отключения correct — либо оставить correct с записью в daily_adds через setCount/подходы, либо убрать по плану после внедрения PATCH/DELETE approaches). После портирования данных и перевода чтения (status, records, history) на daily_adds бот должен писать только в daily_adds; запись в daily_counts отключается.

**Прочие компромиссы:**
- Старые дни в базе представлены одним «синтетическим» подходом за день (без разбивки на реальные подходы по времени).
- Объём данных растёт: вместо одной строки на (user, date) — много строк (по числу подходов). Нужны индексы по (user_id, date), при аналитике — по created_at; для рекордов — фильтр по `migrated = FALSE`. В v2 в daily_adds нет chat_id (см. db-schema-v2).

### 9.3 Остальные направления (миграции, API, correct, сессия и т.д.)

**A. Рекорды и API (актуально до перехода на модель подходов)**

- В **POST /add** (API) после addCount вызывать **updateRecord** с переданным delta как count (или при необходимости передавать max_add отдельно, если в WebApp будет несколько значений). Либо вызывать syncUserRecord(userId) после addCount, чтобы рекорд дня пересчитывался по daily_counts. Так рекорды будут совпадать при добавлении из бота и из WebApp.
- Документировать, что record_count = лучший день по сумме за день, max_add = лучший разовый add (только из бота при текущей логике; при желании — хранить «лучший разовый add» и из API).

**B. Миграции**

- Ввести нумерованные миграции (отдельная папка, например `migrations/`, файлы `001_initial.sql`, `002_xxx.sql`). В initDb оставить только создание таблицы migration_versions и вызов «runner’а», который применяет неприменённые файлы по порядку. Всю текущую логику initDb (CREATE TABLE, DO $$, бэкфилл) перенести в первую миграцию; следующие изменения — только новые файлы. Так проще откатываться и тестировать на копии БД.

**C. Таблица records**

- После перехода на миграции пометить `records` как deprecated: перестать писать в неё, оставить только чтение в initDb для однократной синхронизации в user_records (если ещё есть старые данные). В коде оставить комментарий «только для миграции». В дальнейшей миграции можно DROP TABLE records после проверки, что user_records заполнены и старые клиенты не нужны.

**D. correct и отрицательные значения**

- В setCountForUserDate и addCount: либо явно ограничивать итоговый count >= 0 (например, при subtract не уходить ниже нуля), либо ввести правило «count не может быть отрицательным» и в correct при попытке уйти ниже нуля выставлять 0 и писать об этом в ответ пользователю.

**E. Сессия бота**

- При необходимости нескольких инстансов бота — вынести session в Redis (telegraf-session-redis или аналог). Для одного инстанса оставить память; при масштабировании — обязательный шаг.

**F. Идемпотентность и гонки**

- Для критичных операций (add/correct за один день) можно ввести короткие блокировки: например, SELECT ... FOR UPDATE по строке (chat_id, user_id, date) в одной транзакции с addCount, или advisory lock по (userId, date). Это уменьшит риск дублирования или «потерянного» обновления при высокой нагрузке.

**G. Удаление сообщений**

- Вариант: вынести очередь удалений в Redis с TTL; воркер(ы) по таймеру читают ключи и вызывают deleteMessage. При падении процесса очередь не теряется. Минимальный вариант — оставить как есть и принять риск «не удалённых» сообщений при падении.

**H. Разделение процессов**

- Явно разделить «бот» и «API + статика» на два процесса/контейнера. initDb вызывать при старте каждого (идемпотентно) или один раз из отдельного job/init‑контейнера. Токен и БД общие; масштабировать можно только API, бота — один инстанс (пока не решена сессия в Redis).

**I. Токен и безопасность**

- Оставить один токен на чат; в API при необходимости проверять, что user_id из тела/query «принадлежит» чату (например, что у этого user_id есть записи в этом чате или в shared_chats). Не обязательно хранить user_id в токене — достаточно chat_id + проверки прав при запросе истории.

**J. Компромиссы**

- **Потеря «старых» records:** если когда‑то убрать таблицу records, откат к старым per‑chat рекордам будет невозможен; к этому моменту user_records должен быть единственным источником правды.
- **Отрицательные count:** если ввести ограничение count >= 0, существующие отрицательные значения нужно один раз исправить миграцией (например, обнулить или скорректировать вручную).
- **Два процесса и initDb:** при двух процессах оба могут вызвать initDb; блокировка advisory снимает гонку, но миграции выполняются дважды (должны быть идемпотентными).

Итог: архитектуру можно усилить пошагово. Приоритетно — переход на модель подходов (§9.2), если нужны редактирование/удаление подходов, рекорды из сырых данных и аналитика по времени. Остальное (API + рекорды, миграции, очистка records, ограничения по count, сессия, очередь удалений) дополняет стабильность без потери данных, с явно зафиксированными компромиссами там, где отказ от старого поведения неизбежен.
